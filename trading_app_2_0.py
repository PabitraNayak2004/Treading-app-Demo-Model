# -*- coding: utf-8 -*-
"""Trading app 2.0

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wqpay0QTD6TXO5cP8_hbJvVuz7u8gByq
"""

pip install yfinance pandas vaderSentiment

import yfinance as yf
import pandas as pd
import numpy as np
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

ticker = "AAPL"
df = yf.download(ticker, start="2023-01-01", end="2024-12-31", auto_adjust=True)

df.reset_index(inplace=True)
df.columns = ['_'.join(col) if isinstance(col, tuple) else col for col in df.columns]

df.head()

if 'Adj Close' in df.columns:
    df.rename(columns={'Adj Close': 'Close'}, inplace=True)
elif 'Close_AAPL' in df.columns:
    df.rename(columns={'Close_AAPL': 'Close'}, inplace=True)

df['Date_'] = pd.to_datetime(df['Date_'])

df.head()

news_data = {
    'Date': ['2023-01-03', '2023-01-04', '2023-01-05'],
    'Headline': [
        'Apple releases new iPhone model',
        'Stock markets tumble after inflation news',
        'Strong demand boosts Apple sales forecast'
    ]
}

news_df = pd.DataFrame(news_data)
news_df['Date'] = pd.to_datetime(news_df['Date'])

analyzer = SentimentIntensityAnalyzer()
news_df['Sentiment'] = news_df['Headline'].apply(lambda x: analyzer.polarity_scores(x)['compound'])

sentiment_df = news_df.groupby('Date')['Sentiment'].mean().reset_index()
sentiment_df['Date'] = pd.to_datetime(sentiment_df['Date'])

print(df.columns)

df.rename(columns={'Date_': 'Date'}, inplace=True)

merged_df = pd.merge(df, sentiment_df, on='Date', how='left')
merged_df['Sentiment'] = merged_df['Sentiment'].fillna(0)

df.columns

merged_df.columns = ['_'.join(col) if isinstance(col, tuple) else col for col in merged_df.columns]

for col in merged_df.columns:
    if "Close" in col and col != "Close":
        merged_df.rename(columns={col: "Close"}, inplace=True)

df.columns

data = merged_df[['Close', 'Sentiment']].copy()
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data)

X, y = [], []
sequence_length = 60

for i in range(sequence_length, len(scaled_data)):
    X.append(scaled_data[i-sequence_length:i])
    y.append(scaled_data[i, 0])  # Predict 'Close'

X, y = np.array(X), np.array(y)

model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(X.shape[1], X.shape[2])))
model.add(Dropout(0.2))
model.add(LSTM(50, return_sequences=False))
model.add(Dropout(0.2))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mean_squared_error')
model.fit(X, y, epochs=10, batch_size=32)

last_60_days = scaled_data[-60:]
pred_input = np.expand_dims(last_60_days, axis=0)

pred_scaled = model.predict(pred_input)
pred_price = scaler.inverse_transform([[pred_scaled[0][0], 0]])[0][0]

print("\n‚úÖ Prediction Complete!")
print("üìÖ Next Day Predicted Closing Price:", f"${pred_price:.2f}")

plt.plot(y[-100:], label="Actual Close")
plt.plot(model.predict(X[-100:]), label="Predicted Close")
plt.title("Actual vs Predicted Close Price")
plt.legend()
plt.show()

# Get last prediction date from merged_df
last_date = merged_df['Date'].max()

# Download next day's actual price
next_day = last_date + pd.Timedelta(days=1)
next_day_end = last_date + pd.Timedelta(days=2)
actual_df = yf.download(ticker, start=next_day, end=next_day_end, auto_adjust=True)

if 'Adj Close' in actual_df.columns:
    actual_price = actual_df['Adj Close'].values[0]
else:
    actual_price = actual_df['Close'].values[0]

print(f"\nüìÖ Last date in training: {last_date.date()}")
print(f"üìà Predicted Next Day Price: ${pred_price:.2f}")
print(f"üìä Actual Next Day Price   : ${actual_price[0]:.2f}")

predicted_prices = model.predict(X[-100:])
true_prices = y[-100:]

# Inverse transform both to original scale
inv_pred = scaler.inverse_transform(np.hstack([predicted_prices, np.zeros((len(predicted_prices), 1))]))[:, 0]
inv_true = scaler.inverse_transform(np.hstack([true_prices.reshape(-1, 1), np.zeros((len(true_prices), 1))]))[:, 0]

# Plot
plt.figure(figsize=(10, 5))
plt.plot(inv_true, label="Actual Price")
plt.plot(inv_pred, label="Predicted Price")
plt.title("üìà LSTM Model - Actual vs Predicted Prices")
plt.xlabel("Days")
plt.ylabel("Stock Price")
plt.legend()
plt.grid(True)
plt.show()

mae = mean_absolute_error(inv_true, inv_pred)
rmse = np.sqrt(mean_squared_error(inv_true, inv_pred))

print(f"\nüìè Mean Absolute Error (MAE): {mae:.2f}")
print(f"üìè Root Mean Squared Error (RMSE): {rmse:.2f}")

# Save the trained model
model.save("stock_lstm_model.h5")
print("‚úÖ Model saved as 'stock_lstm_model.h5'")

